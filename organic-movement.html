<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#24AFD0"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-01-30T12:05:15.8531169"><title>GMC Organic Movement | Unreal Development References</title><script type="application/json" id="virtual-toc-data">[{"id":"tick-tock","level":0,"title":"Tick() tock...","anchor":"#tick-tock"},{"id":"custom-movement-modes-versus-extending-existing-ones","level":0,"title":"Custom Movement Modes versus Extending Existing Ones","anchor":"#custom-movement-modes-versus-extending-existing-ones"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="images/Rooi.svg"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="GMC Organic Movement | Unreal Development References"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Unreal Development References Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/organic-movement.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="GMC Organic Movement | Unreal Development References"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/organic-movement.html#webpage",
    "url": "writerside-documentation/organic-movement.html",
    "name": "GMC Organic Movement | Unreal Development References",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Unreal Development References Help"
}</script><!-- End Schema.org --></head><body data-id="Organic-Movement" data-main-title="GMC Organic Movement" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="General-Movement-Component.md|General Movement Component"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Unreal Development References  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Organic-Movement" id="Organic-Movement.md">GMC Organic Movement</h1><p id="-glmejm_3">GMC's replication logic is in the Replication Component (a child of the Pawn Navigation Component), and much of the useful logic to handle movement generically is in the Movement Utility Component; if you are trying to design something wildly different than the normal human movement systems -- a flight simulator, spaceship combat, a top-down 2D spaceship bullet-hell game, whatever -- then the Movement Utility Component is what you'll likely be extending.</p><p id="-glmejm_4">That, however, is something of an advanced use case.</p><p id="-glmejm_5">For normal human movement -- the equivalent of Unreal's default Character Movement Component -- you'll almost certainly be working with either the <span class="control" id="-glmejm_9">Organic Movement Component</span> or its child, the <span class="control" id="-glmejm_10">GoldSrc Movement Component</span>. This document will focus on how the Organic Movement Component works; some of this is true of the Movement Utility Component in general, but some is specific to the organic movement setup.</p><p id="-glmejm_6">Reading the existing <a href="https://grimtec.net/gmcv2-doc-beginners-guide-organic-movement-overview/" id="-glmejm_11" data-external="true" rel="noopener noreferrer">GMC Organic Movement Guide</a> on the actual GMC website is recommended. In particular, the section labeled &quot;Entry Points&quot; is relevant to everything that will be discussed here. Go do that now; we'll wait.</p><section class="chapter"><h2 id="tick-tock" data-toc="tick-tock">Tick() tock...</h2><p id="-glmejm_12">One of the first things people notice about the Organic Movement Component is that there are three <code class="code" id="-glmejm_18">Tick</code> functions: <code class="code" id="-glmejm_19">GenPredictionTick</code>, <code class="code" id="-glmejm_20">GenSimulationTick</code>, and <code class="code" id="-glmejm_21">GenAncillaryTick</code>. And one of the things they often immediately ask is &quot;wait, what does each of these tick functions mean?&quot;</p><p id="-glmejm_13">The answer is fairly simple:</p><ul class="list _bullet" id="-glmejm_14"><li class="list__item" id="-glmejm_22"><p><span class="control" id="-glmejm_25">GenPredictionTick</span> is the general purpose tick for predicted movement. Generally this will be on autonomous proxies and authorities (e.g. the client which 'owns' a character, and the server), though it <span class="emphasis" id="-glmejm_26">may</span> run on simulated proxies in some specific smoothing scenarios (where prediction is required). In single-player scenarios, this is the equivalent to the normal Tick and run each frame; in multiplayer, it will handle replays and sub-stepping as needed.</p></li><li class="list__item" id="-glmejm_23"><p><span class="control" id="-glmejm_27">GenSimulationTick</span> is called <span class="emphasis" id="-glmejm_28">only</span> on simulated proxies, and is used when what's replicated isn't sufficient to accurately represent the pawn's state. This is what gets called during smoothing.</p></li><li class="list__item" id="-glmejm_24"><p><span class="control" id="-glmejm_29">GenAncillaryTick</span> is called <span class="emphasis" id="-glmejm_30">only</span> on autonomous proxies or the authority, and always after GenPredictionTick. However, unlike GenPredictionTick, it will not be called during replay or substepping. This is generally used for predicted non-movement logic -- things which you want to be in sync with the movement lifecycle, but which you don't want to replay if the client and server are trying to get back in sync. For instance, things like &quot;fire this weapon&quot; are generally going to be something you want to have in step with the movement lifecycle and handle predictively, but <span class="emphasis" id="-glmejm_31">not</span> a thing you want to replay in resolving a movement desync.</p></li></ul><p id="-glmejm_15">Which Tick should you put something in? Ask yourself a few questions:</p><ol class="list _decimal" id="-glmejm_16" type="1"><li class="list__item" id="-glmejm_32"><p><span class="control" id="-glmejm_36">Is this a single-player game (and one where multiplayer will probably never be a consideration)?</span> Then just use <span class="control" id="-glmejm_37">GenPredictionTick</span>.</p></li><li class="list__item" id="-glmejm_33"><p><span class="control" id="-glmejm_38">Is this logic which will need to be run during rollback/replay?</span> Then <span class="control" id="-glmejm_39">GenPredictionTick</span> is probably the right place.</p></li><li class="list__item" id="-glmejm_34"><p><span class="control" id="-glmejm_40">Is this logic which needs to run on a simulated proxy?</span> Things that might touch off specific animations or such on a simulated proxy should probably be in <span class="control" id="-glmejm_41">GenSimulationTick</span> as well as <span class="control" id="-glmejm_42">GenPredictionTick</span>.</p></li><li class="list__item" id="-glmejm_35"><p><span class="control" id="-glmejm_43">Are none of the above true?</span> If it's not movement, doesn't need to be handled during replay, and doesn't need to be on a simulated proxy, then <span class="control" id="-glmejm_44">GenAncillaryTick</span> is probably your... <span class="control" id="-glmejm_45">tick</span>et. (I'm not sorry.)</p></li></ol><p id="-glmejm_17">As an example, over in GMAS (see the &quot;Useful GMC Resources&quot; page), this is why we distinguish between movement abilities and non-movement abilities. Movement abilities <span class="emphasis" id="-glmejm_46">will</span> be replayed when resolving a desync (such as &quot;jump&quot; or &quot;start sprinting&quot; or whatnot), while non-movement abilities (&quot;cast this spell&quot; or &quot;fire this gun&quot;) are handled on the Ancillary Tick instead.</p></section><section class="chapter"><h2 id="custom-movement-modes-versus-extending-existing-ones" data-toc="custom-movement-modes-versus-extending-existing-ones">Custom Movement Modes versus Extending Existing Ones</h2><p id="-glmejm_47">One thing that seems to confuse a lot of people is whether they should be sticking things into <code class="code" id="-glmejm_51">MovementUpdate</code>, or somewhere else. And a good basic guideline when extending the Organic Movement Component is to ask yourself &quot;is this a bit of extra logic on an existing movement mode's physics?&quot;</p><p id="-glmejm_48">For something like adding Crouch or Jump or whatnot, the answer is probably &quot;yes.&quot; Looking at GMC's own Gold Source Movement Component will show how those sort of things can be easily added in <code class="code" id="-glmejm_52">MovementUpdate</code>. Even if you're changing the base movement behavior, if you're <span class="emphasis" id="-glmejm_53">mostly</span> using the same logic as an existing mode, you could just override the <code class="code" id="-glmejm_54">PhysicsGrounded</code> function. For something like altering the rotation logic -- such as with the &quot;Orient to Velocity Direction&quot; feature I added to GMC Extended -- just overriding <code class="code" id="-glmejm_55">ApplyRotation</code> is probably enough.</p><p id="-glmejm_49">But if you have movement logic <span class="emphasis" id="-glmejm_56">so</span> different from an existing mode that you'd be using very little of the logic, making an entire new movement mode (and implementing your own physics in <code class="code" id="-glmejm_57">PhysicsCustom</code>) is probably the right call.</p><p id="-glmejm_50">There are some things which are borderline cases, of course. If, for instance, you have a parachute you can use... there are reasons to handle it entirely in Airborne and just slow the acceleration due to gravity. There are also reasons you might want it to be its own movement mode, such as if you have specific fall control logic with a parachute and don't support fall control when in free-fall.</p></section><div class="last-modified">Last modified: 30 January 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="gmc-lifecycle.html" class="navigation-links__prev">GMC Concepts and Lifecycle</a><a href="useful-gmc-resources.html" class="navigation-links__next">Useful GMC Resources</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>