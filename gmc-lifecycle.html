<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#24AFD0"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-09-29T12:54:02.2744549"><title>GMC Concepts and Lifecycle | Unreal Development References</title><script type="application/json" id="virtual-toc-data">[{"id":"moves","level":0,"title":"Moves","anchor":"#moves"},{"id":"authority","level":0,"title":"Authority","anchor":"#authority"},{"id":"how-it-fits-together","level":0,"title":"How It Fits Together","anchor":"#how-it-fits-together"},{"id":"caveats","level":0,"title":"Caveats","anchor":"#caveats"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="images/Rooi.svg"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="GMC Concepts and Lifecycle | Unreal Development References"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Unreal Development References Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/gmc-lifecycle.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="GMC Concepts and Lifecycle | Unreal Development References"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/gmc-lifecycle.html#webpage",
    "url": "writerside-documentation/gmc-lifecycle.html",
    "name": "GMC Concepts and Lifecycle | Unreal Development References",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Unreal Development References Help"
}</script><!-- End Schema.org --></head><body data-id="GMC-Lifecycle" data-main-title="GMC Concepts and Lifecycle" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="General-Movement-Component.md|General Movement Component"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Unreal Development References  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="GMC-Lifecycle" id="GMC-Lifecycle.md">GMC Concepts and Lifecycle</h1><p id="ievp86_3">The well-defined life cycle of the General Movement Component is one of its most powerful features, lending itself well to consistent, predictable behaviors. However, it's also one of the things that people struggle with the most when starting out, given how different it is from the stock Character Movement Component.</p><p id="ievp86_4">So we're going to break down some of the basics.</p><section class="chapter"><h2 id="moves" data-toc="moves">Moves</h2><p id="ievp86_10">The basic operational 'block' of the GMC is a Move. Think of a move as a single 'frame' for purposes of the GMC, all boxed up and ready to be shipped or put on a shelf. But the thing that is important to remember is that, for the purposes of the average user, the move stores really two things: the state of things <span class="emphasis" id="ievp86_17">before</span> the move (Input) and the state of things <span class="emphasis" id="ievp86_18">after</span> the move (Output).</p><p id="ievp86_11">The flow ends up being something like:</p><div class="code-block" data-lang="none">- GMC Pre-movement
- [ handle Input state ]
+ GMC Movement
- [ handle Output state ]
- GMC Post-movement
</div><p id="ievp86_13">We'll say that the lines with a <code class="code" id="ievp86_19">-</code> happen outside of the GMC movement update, and the <code class="code" id="ievp86_20">+</code> happens inside. (Just so that it makes some later illustrations more clear.)</p><p id="ievp86_14">As you can see, only changes which happen during the 'Movement' phase are going to be recorded in the Output state; if you make changes to things <span class="emphasis" id="ievp86_21">after</span> the Output state is recorded, they aren't going to be handled until the next movement cycle.</p><p id="ievp86_15">Now, one advantage here is that by virtue of each 'move' being a defined set of variables (including whatever variables you bound), if things are out-of-sync, it's possible to rewind to the last 'good' state and then replay the moves atop it to resolve things.</p><p id="ievp86_16">There are also a couple of caveats, discussed in the Caveats section.</p></section><section class="chapter"><h2 id="authority" data-toc="authority">Authority</h2><p id="ievp86_22">When binding variables for replication, one of the values that puzzles people is what the Prediction setting is for. The answer is simple: who gets to say what reality is?</p><p id="ievp86_23">The answer to <span class="emphasis" id="ievp86_32">that</span> question is in the form <code class="code" id="ievp86_33">[Role]Auth_[State]</code> and a &quot;who should validate this&quot; of <code class="code" id="ievp86_34">_[Role]Validated</code> on the end of certain things.</p><p id="ievp86_24">The <code class="code" id="ievp86_35">[State]</code> portion will be <code class="code" id="ievp86_36">Input</code>, <code class="code" id="ievp86_37">Output</code>, or <code class="code" id="ievp86_38">InputOutput</code>. Unsurprisingly, these refer to those Input and Output states mentioned in the flow above: <code class="code" id="ievp86_39">Input</code> applies to the values as they were in the Input state, <code class="code" id="ievp86_40">Output</code> to the values as of the Output state, and <code class="code" id="ievp86_41">InputOutput</code> to both.</p><p id="ievp86_25">A great many things are already handled under the hood for you -- character transform, controller orientation, current linear velocity, etc. These will be recorded, provided in the Input values, and verified in the Output values all behind the scenes without you needing to do anything.</p><p id="ievp86_26">Generally, you will only be using two prediction modes for anything you bind for yourself: <code class="code" id="ievp86_42">ClientAuth_Input</code> and <code class="code" id="ievp86_43">ServerAuth_Output_ClientValidated</code>.</p><p id="ievp86_27">But let's break down what those <span class="emphasis" id="ievp86_44">mean</span>.</p><section class="chapter"><h3 id="clientauth" data-toc="clientauth">ClientAuth</h3><p id="ievp86_45">The <code class="code" id="ievp86_49">ClientAuth</code> prediction values mean that the client (the player) gets to determine objective truth; the server will blindly trust what the client says and adopt its values. You will note there is no <code class="code" id="ievp86_50">_[Role]Validated</code> on the end, because the server can't know the values to have them validated in the first place. As a result, this should <span class="emphasis" id="ievp86_51">only</span> be used for values that the server has <span class="emphasis" id="ievp86_52">no way of knowing</span>, and which the client can inherently be trusted about.</p><p id="ievp86_46">Most commonly, this will be things like player input; under the hood, the player input that GMC already handles for you (e.g. movement and looking around) is bound as various <code class="code" id="ievp86_53">ClientAuth_Input</code> values. This means the client values will be adopted (overwriting whatever the values were on the server) when handling the Input state, and when the server executes the moves it will have the same values the client did available to it.</p><p id="ievp86_47">Unsurprisingly, <code class="code" id="ievp86_54">ClientAuth_Output</code> will do the same thing with the output state -- overwriting whatever the server's value was <span class="emphasis" id="ievp86_55">after</span> the movement cycle (during the Output state), and <code class="code" id="ievp86_56">ClientAuth_InputOutput</code> will do that both at the Input <span class="emphasis" id="ievp86_57">and</span> the Output states. (These modes are not commonly used, though there are niche applications for them; generally all your <code class="code" id="ievp86_58">ClientAuth</code> values will be <code class="code" id="ievp86_59">ClientAuth_Input</code>.)</p><p id="ievp86_48">To use a common example -- making the player jump -- you could have a <code class="code" id="ievp86_60">Wants to Jump</code> value bound <code class="code" id="ievp86_61">ClientAuth_Input</code>, and when you pressed the jump button you set <code class="code" id="ievp86_62">Wants to Jump</code> to <code class="code" id="ievp86_63">true</code> (and to <code class="code" id="ievp86_64">false</code> when the jump button is released); you can set that value anywhere (on the client, where the input is) and it won't matter, as the value at the time of the 'handle Input state' will be what is recorded into the Move.</p></section><section class="chapter"><h3 id="serverauth" data-toc="serverauth">ServerAuth</h3><p id="ievp86_65"><code class="code" id="ievp86_69">ServerAuth</code> values are ones where the server's value is the source of ground truth, and the vast majority of what you bind this way will be <code class="code" id="ievp86_70">ServerAuth_Output_ClientValidated</code>. Things like the player location are server authoritative.</p><p id="ievp86_66"><code class="code" id="ievp86_71">ClientValidated</code> versus <code class="code" id="ievp86_72">ServerValidated</code> can best be thought of as &quot;who is responsible for resolving the issue if things don't match.&quot; <code class="code" id="ievp86_73">ClientValidated</code> is not any less secure than <code class="code" id="ievp86_74">ServerValidated</code> and will put less pressure on the network traffic, so in nearly all cases you want <code class="code" id="ievp86_75">ClientValidated</code>.</p><p id="ievp86_67">(Again, there are niche scenarios where <code class="code" id="ievp86_76">ServerValidated</code> might be correct, but generally if you are dealing with those niche scenarios you probably are also deep enough into the guts of GMC to understand the implications for yourself.)</p><p id="ievp86_68">When a client adopts a server authoritative value and it gets validated, if the value does <span class="emphasis" id="ievp86_77">not</span> match, this triggers a correction; the vast majority of the time, GMC will handle the correction for you fairly automatically... at least, as long as all of your movement logic takes place within the Movement portion of the lifecycle.</p></section><section class="chapter"><h3 id="local" data-toc="local">Local</h3><p id="ievp86_78">There is also a 'Local' prediction binding. Things bound <code class="code" id="ievp86_79">Local</code> will not be replicated at all, but <span class="emphasis" id="ievp86_80">will</span> be recorded in the movement history. This is a fairly advanced (and niche) use case, where you have local state that needs to be recorded for potential playback.</p></section><section class="chapter"><h3 id="messages-from-server-to-client" data-toc="messages-from-server-to-client">Messages from Server to Client</h3><p id="ievp86_81">You will notice there is no unvalidated Server Authenticated binding for prediction. Generally, best practice if the server has unpredicted state to communicate, this will be handled by a standard Unreal RPC call; after all, if it can <span class="emphasis" id="ievp86_82">only</span> be known by the server, the client has no way to predict it.</p></section></section><section class="chapter"><h2 id="how-it-fits-together" data-toc="how-it-fits-together">How It Fits Together</h2><p id="ievp86_83">By now, you can probably see how the little blocks of logic work out nicely: each movement frame ensures you have a predictable state shared between server and client going into the movement cycle. This includes things like merging a remote movement state into the move history and validating things. It also allows GMC to combine multiple moves if nothing in the Input or Output state has changed (or at least, nothing which says &quot;I've changed enough to require an update&quot;, based on the Combine value in the binding); this can reduce overall network traffic by sending one larger movement.</p><p id="ievp86_84">That's really quite an oversimplification, and there's <span class="emphasis" id="ievp86_88">quite</span> a lot of fairly complex code under the hood that makes that all work -- really, the replication logic is at the heart of the GMC -- but it works well enough as an explanation.</p><p id="ievp86_85">The practical upshot of this is that each time you end up in the <code class="code" id="ievp86_89">Movement Update</code> portion of the GMC lifecycle, you have a fairly reliable set of Input values coming in to operate on both on the client <span class="emphasis" id="ievp86_90">and</span> the server -- letting them run the same logic on the same values more or less at the same time -- and a set of recorded Output values which can be validated, and (if they differ), rewound to try to resolve the difference (or simply adopted outright if the values can't be resolved).</p><section class="chapter"><h3 id="gmc-aggregator-and-gmc-world-time-replicator" data-toc="gmc-aggregator-and-gmc-world-time-replicator">GMC Aggregator and GMC World Time Replicator</h3><p id="ievp86_91">Now, one thing that's worth noting is that in order to keep the timestamp in sync across all the various bits of GMC (and all the clients) to allow things to be resolved, you <span class="emphasis" id="ievp86_93">do</span> need to add a special actor of <code class="code" id="ievp86_94">GMCWorldTimeReplicator</code> to the world. Generally for simple maps you can just add this to the level you load. If this is missing, GMC is gonna not work well.</p><p id="ievp86_92">One nice bit of additional optimization is that if you put a special <code class="code" id="ievp86_95">GMCAggregator</code> actor into your level, all the GMC movement components will find it, register with it, and the movement components will all get manually ticked by the Aggregator at the same time. It isn't <span class="emphasis" id="ievp86_96">required</span> but it's sure a nice thing to have.</p></section><section class="chapter"><h3 id="a-practical-example-jumping" data-toc="a-practical-example-jumping">A Practical Example (Jumping)</h3><p id="ievp86_97">Earlier, we noted that you could bind a <code class="code" id="ievp86_105">Wants to Jump</code> value as <code class="code" id="ievp86_106">ClientAuth_Input</code>. To demonstrate what that <span class="emphasis" id="ievp86_107">means</span>, however, let's take a look at this. Again, <code class="code" id="ievp86_108">-</code> will be logic that happens outside of the Movement cycle.</p><p id="ievp86_98"><span class="control" id="ievp86_109">Client</span></p><div class="code-block" data-lang="none">- [ player presses the jump button, we set a `Wants to Jump` on our movement component ]
- ... various Unreal stuff ...
- GMC Pre Movement
- [ handle Input state, recording Wants to Jump value ]
+ GMC Movement starts
+ [ in movement update, see that Wants to Jump is true, so apply upward impulse to make the player jump ]
+ GMC Movement ends
- [ handle Output state ]
- GMC Post Movement
</div><p id="ievp86_100">As you can see, because the <code class="code" id="ievp86_110">Wants to Jump</code> was set to true outside in general Unreal stuff, it gets recorded into the Input state, and then the client can act on it by actually jumping even without the server having said to jump yet.</p><p id="ievp86_101"><span class="control" id="ievp86_111">Server</span></p><div class="code-block" data-lang="none">- ... various Unreal stuff
- GMC Pre Movement
- [ handle Input state, adopting the client's authoritative Wants to Jump value ]
+ GMC Movement starts
+ [ in movement update, see that Wants to Jump is true, so apply upward impulse to make the player jump ]
+ GMC Movement ends
- [ handle Output state ]
- GMC Post Movement
</div><p id="ievp86_103">On the server side, we have our client's <code class="code" id="ievp86_112">Wants to Jump</code> value applied seamlessly for us, which means we can perform the exact same &quot;make me jump&quot; action on the server side as we did on the client side. The client isn't waiting to hear from the server before it jumps, but will correct itself if the server says &quot;nope&quot;.</p><p id="ievp86_104">This is 'predictive movement', and it helps a <span class="emphasis" id="ievp86_113">great deal</span> in making a responsive multiplayer experience even in bad network latency conditions. It is the heart and soul of the GMC, and making predictive movement comparatively easy is why the GMC is so powerful.</p></section></section><section class="chapter"><h2 id="caveats" data-toc="caveats">Caveats</h2><p id="ievp86_114">Despite making predictive movement (and resolving differences and applying corrections) about as painless as possible for such a complicated network topic, there are still some caveats to all of this.</p><section class="chapter"><h3 id="outside-dependencies" data-toc="outside-dependencies">Outside Dependencies</h3><p id="ievp86_117">One that is probably immediately obvious is that if a value is important to the GMC movement logic but is <span class="emphasis" id="ievp86_123">not</span> bound, any attempt to replay things is going to get... messy.</p><p id="ievp86_118">A good example would be trying to use Epic's Gameplay Ability System (GAS) with the GMC. GAS has its own way of replicating things, which means values will propagate outside of the GMC movement lifecycle (and not be recorded in the GMC moves).</p><p id="ievp86_119">Let's say you have a <code class="code" id="ievp86_124">Stamina</code> attribute in GAS. You check this attribute value in your GMC movement logic in order to check if you can move or not. Yay, that's all good! But now let's say you run out of stamina <span class="emphasis" id="ievp86_125">and</span> GMC also needs to replay a move to resolve a difference. Now when it goes to handle the movement logic for a recorded move where you had enough stamina, it goes &quot;Oh, you can't move&quot; and things become further out of sync, incurring more (and more serious) client corrections.</p><p id="ievp86_120">Obviously you could get around this by copying your GAS Stamina value into a bound GMC variable in the <code class="code" id="ievp86_126">Pre Local Movement</code> function, and using the bound variable for your actual movement calculations. But the number of things you'd have to do that with quickly adds up and becomes annoyingly problematic (and it's easy to slip up with).</p><p id="ievp86_121">So in short, the more of your movement state you can keep within the GMC, the happier it -- and you -- are going to be.</p><p id="ievp86_122">GAS is admittedly a particularly severe example. (In fact, it's actually <span class="emphasis" id="ievp86_127">such</span> a severe example that it inspired a GAS equivalent written entirely atop the GMC, the GMC Ability System, or &quot;GMAS&quot;, which can be found on the &quot;Useful GMC Resources&quot; page.)</p></section><section class="chapter"><h3 id="listen-server-smoothing" data-toc="listen-server-smoothing">Listen Server Smoothing</h3><p id="ievp86_128">Listen servers are a bit of a weird scenario. Inherently, the movements of a remote client are going to be slightly lower fidelity, because it's not sending every single frame of movement; if you just saw the raw <span class="emphasis" id="ievp86_142">network</span> values for a GMC pawn, it would be stutter-stepping something fierce.</p><p id="ievp86_129">So on clients, these remote pawns have smoothing applied, where GMC generates the various 'in between' frames for the character position and such. This makes for a much nicer experience, and makes their movement fluid and seamless. And since you're not altering the GMC-maintained state of simulated pawns outside of the movement lifecycle (at least, you shouldn't be; that should be the responsibility of the owning client or the server), there's no issue here.</p><p id="ievp86_130">Obviously, the server does not have this smoothing applied; you want the server to know the authoritative values, not the pretty visual smoothing. Which means you can still change the pawn state outside the GMC movement lifecycle, and it will be handled in that &quot;pick up the Input state&quot; portion of the cycle.</p><p id="ievp86_131">However, a <span class="emphasis" id="ievp86_143">listen</span> server is also acting as a client, and as a result the pawn being displayed to the player outside of the GMC lifecycle is a smoothed pawn. The actual server state of the pawn is hidden away, not used for the visual display. In effect, on a listen server, two copies of the pawn exist -- the one you see (the simulated pawn, on the portion of your game working as a client) and the one the server cares about (the pawn which the server portion of your game keeps an authoritative copy of).</p><p id="ievp86_132">But <span class="emphasis" id="ievp86_144">Unreal itself</span> doesn't know about the hidden-away authoritative server pawn, it only knows the one displayed on the screen. And if you make changes to that simulated pawn, they're just going to get overwritten in the next movement cycle (because the simulated pawn is actually being driven by GMC from the hidden server pawn).</p><p id="ievp86_133">The <span class="emphasis" id="ievp86_145">practical</span> upshot of this is that if you need to use any of the normal actor values -- the location, rotation, linear velocity, whatever -- outside of the GMC movement lifecycle <span class="emphasis" id="ievp86_146">as a server</span>, you want to wrap those in a pair of <code class="code" id="ievp86_147">SV Swap Server State</code> calls. On a listen server, this will temporarily swap the two pawns, letting you access or change the hidden authoritative pawn; on a dedicated server, it will do nothing (as you only have the authoritative pawn).</p><p id="ievp86_134">Imagine it like this, on a dedicated server:</p><div class="code-block" data-lang="none">- [ server forcefully teleports a player ]
- GMC Pre Movement
- [ handle Input state ]
+ Movement Update (using the new location)
- [ handle Output state, recording the new location accounting for the teleport ]
- GMC Post Movement
</div><p id="ievp86_136">That'll work fine. But on a listen server, it would be:</p><div class="code-block" data-lang="none">- [ server forcefully teleports a player ]
- [ ... various Unreal stuff ... ]
- GMC swaps from smoothed simulated pawn to real server pawn, overwriting the location with the server one
- GMC Pre Movement
- [ handle Input state ]
+ Movement Update (using the old location)
- [ handle Output state, recording the new location based on the old location ]
- GMC Post Movement
- GMC swaps from real server pawn back to smoothed simulated pawn
</div><p id="ievp86_138">...which is <span class="emphasis" id="ievp86_148">not</span> going to work particularly well, as you might guess. Sure, you've moved the simulated pawn, but it's going to just get moved by the smoothing based on the server state, and that teleport just functionally didn't happen. But with the addition of the Swap Server State...</p><div class="code-block" data-lang="none">- Swap Server State [ swapping from smoothed simulated pawn to real server pawn ]
- [ server forcefully teleports a player, changing the value on the server pawn ]
- Swap Server State [ swapping from real server pawn to smoothed simulated pawn ]
- [ ... various Unreal stuff ... ]
- GMC swaps from smoothed simulated pawn to real server pawn
- GMC Pre Movement
- [ handle Input state ]
+ Movement Update (using the old location)
- [ handle Output state, recording the new location based on the old location ]
- GMC Post Movement
- GMC swaps from real server pawn back to smoothed simulated pawn 
</div><p id="ievp86_140">Now the authoritative server pawn has been appropriately teleported, the teleport will be propagated to the smoothed pawn (by GMC) <span class="emphasis" id="ievp86_149">and</span> will be reflected in the actual network state of the pawn.</p><p id="ievp86_141">Forgetting to Swap Server State when outside of the movement cycle is perhaps one of the single most common errors to make when working with the GMC, and as it will <span class="emphasis" id="ievp86_150">only</span> show up on Listen servers, it's why it's important to test your multiplayer on both dedicated <span class="emphasis" id="ievp86_151">and</span> listen servers!</p></section></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="ievp86_152">That was probably a lot, but hopefully it has helped lay out a bit more of how the General Movement Component works, and what it can let you do. It's worth noting this is just at the baseline GMC Movement Utility Component, which lacks any real movement logic of its own to speak of; it's the foundation on which you can build your own movement logic.</p><p id="ievp86_153">The GMC does, however, also come with the Organic Movement Component, the GMC equivalent of the Character Movement Component, which provides things like physics and whatnot. We'll cover a bit about the Organic Movement Component on the next page.~~~~</p></section><div class="last-modified">Last modified: 29 September 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="gmc-overview.html" class="navigation-links__prev">Is GMC Right For Your Project?</a><a href="organic-movement.html" class="navigation-links__next">GMC Organic Movement</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b419/app.js"></script></body></html>